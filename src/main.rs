mod critical_section;

use embedded_svc::mqtt::client::{
    EventPayload::Error, EventPayload::Received, QoS,
};
use esp_idf_svc::hal::{delay::Delay, gpio::PinDriver, peripherals::Peripherals};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition, wifi::BlockingWifi, wifi::EspWifi,
};

use embedded_svc::wifi::{ClientConfiguration, Configuration};
use esp_idf_svc::mqtt::client::*;
use loadcell::{hx711::HX711, LoadCell};

/// This configuration is picked up at compile time by `build.rs` from the
/// file `cfg.toml`.
#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("localhost")]
    mqtt_host: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str,
    #[default("")]
    mqtt_client_id: &'static str,
}

fn main() {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();

    log::info!("Hello, world!");

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    log::info!("WIFI Network: {}", app_config.wifi_ssid);

    let sys_loop = EspSystemEventLoop::take().unwrap();
    let nvs = EspDefaultNvsPartition::take().unwrap();

    let esp_wifi = EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs)).unwrap();

    let mut wifi_driver = BlockingWifi::wrap(esp_wifi, sys_loop).unwrap();

    wifi_driver
        .set_configuration(&Configuration::Client(ClientConfiguration {
            ssid: app_config
                .wifi_ssid
                .try_into()
                .expect("Could not parse the given SSID into WiFi config"),
            password: app_config
                .wifi_psk
                .try_into()
                .expect("Could not parse the given password into WiFi config"),
            ..Default::default()
        }))
        .unwrap();

    wifi_driver.start().unwrap();
    wifi_driver.connect().unwrap();
    wifi_driver.wait_netif_up().unwrap();

    println!("Should be connected now");
    println!(
        "IP info: {:?}",
        wifi_driver.wifi().sta_netif().get_ip_info().unwrap()
    );

    log::info!("Connecting to MQTT server");
    let topic = "scale-bed";
    log::info!("test {}", CONFIG.mqtt_host);

    /*
        let (mut mqtt_client, mut mqtt_conn) = EspMqttClient::new(
            CONFIG.mqtt_host,
            &MqttClientConfiguration {
                //client_id: Some(CONFIG.mqtt_client_id),
                password: CONFIG
                    .mqtt_pass
                    .try_into()
                    .expect("Could not parse the given password into MQTT config"),
                username: CONFIG
                    .mqtt_user
                    .try_into()
                    .expect("Could not parse the given username into MQTT config"),
                ..Default::default()
            },
        )
        .unwrap();
    */
    let mut mqtt_client = EspMqttClient::new_cb(
        CONFIG.mqtt_host,
        &MqttClientConfiguration {
            //client_id: Some(CONFIG.mqtt_client_id),
            password: CONFIG
                .mqtt_pass
                .try_into()
                .expect("Could not parse the given password into MQTT config"),
            username: CONFIG
                .mqtt_user
                .try_into()
                .expect("Could not parse the given username into MQTT config"),
            ..Default::default()
        },
        move |message_event| match message_event.payload() {
            Received { data, .. } => log::info!("Received {} bytes", data.len()),
            Error(e) => log::warn!("Received error from MQTT: {:?}", e),
            _ => log::info!("Received from MQTT: {:?}", message_event.payload()),
        },
    )
    .unwrap();

    log::info!("About to start the MQTT client");

    let dt = PinDriver::input(peripherals.pins.gpio16).unwrap();
    let sck = PinDriver::output(peripherals.pins.gpio4).unwrap();
    let delay = Delay::new_default();

    let mut load_sensor = HX711::new(sck, dt, delay);

    log::info!("Start tare");
    load_sensor.tare(16);
    log::info!("Finished tare");

    // factor = (real_weight - tare) / raw_measurement
    load_sensor.set_scale(0.885);
    log::info!("Offset: {:.0} g", load_sensor.get_offset());
    let mut vec = Vec::new();

    loop {
        if load_sensor.is_ready() {
            //let reading = load_sensor.read_scaled().unwrap();
            let reading = load_sensor.read_scaled().unwrap(); // Use this to calibrate the load cell
            vec.push(reading);
            // log::info!("Weight: {:.0} g", reading);
            //log::info!("Weight scaled   : {:.0} g", reading_scaled);
            // log::info!("Weight: {} g", reading); // Use this to get all the decimals

            if vec.len() == 20 {
                vec.sort_by(|a, b| a.partial_cmp(b).unwrap());
                let median = vec.get(10).unwrap();
                let payload = format!("{}", median);

                mqtt_client
                    .publish(topic, QoS::AtMostOnce, false, payload.as_bytes())
                    .unwrap();

                log::info!("Published \"{payload}\" to topic \"{topic}\"");
                vec.clear();
            }
        }
        delay.delay_ms(5u32);
    }
}
